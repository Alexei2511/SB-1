int testSudoku(int *mas0, int c = 3, bool debug = false, bool write_in_file = true, int max = 0, const char *fn="")
{
    int c2 = c*c, c3 = c*c*c, c4 = c*c*c*c;
    int i, j, k, l, mod, v, col, row, box;
    int *mas = new int[c4];
    int *test = new int[3*c4];
    bool b;
    char *fname;
    FILE *f;
    // заполняем таблицу
    for(i = 0; i < c4; i++)
        mas[i] = ((mas0[i] > 0) || (mas0[i] <= c2))? mas0[i] : 0;
    // имя файла в который идет запись
    if(write_in_file){
        if(fn == ""){
            l = c4 + 6;
            fname = (char*)malloc(l + 1);
            for(i = 0; i < c4; i++)
                fname[i] = '0' + mas[i];
            strcpy(fname + c4, ".table");
            fname[l] = '\0';
        }else{
            l = strlen(fn);
            fname = (char*)malloc(l + 1);
            strcpy(fname, fn);
            fname[l] = '\0';
        }
        f = fopen(fname, "w");
        free(fname);
    }
    // проверка на валидность таблицы
    for(i = 0; i < 3 * c4; i++)
        test[i] = 1;
    for(i = 0; i < c4; i++){
        v = mas[i] - 1;
        if(v >= 0){
            col = i % c2;
            row = int(i / c2);
            box = int(col / c) + int(row / c) * c;
            test[col * c2 + v]--;
            test[c4 + row * c2 + v]--;
            test[2 * c4 + box * c2 + v]--;
        }
    }
    // если таблица невалидна вернуть -1
    for(i = 0; i < 3 * c4; i++)
        if(test[i] < 0)
            return -1;
    // заполняем таблицу неизменными базовыми числами и значениями по умолчанию
    for(i = 0; i < c4; i++)
        mas[i] = (mas0[i] && (mas0[i] >= -c2) && (mas0[i] <= c2))? mas0[i] : -c2;
    // итеративный обход полей таблицы
    // обход происходит в прямом порядке позиций 0,1,2,3,4,...,80
    //                и в прямом порядке чисел -9,-8,-7,-6,-5,...,-1
    for(i = 0, k = 0, mod = 0; i >= 0;){
        if(i == c4){
            // если решение найдено
            k++;
            if(max)
                if(k > max){
                    if(debug)
                        printf("max\n",k);
                    break;
                }
            if(debug)
                printf("%d)\n",k);
            if(write_in_file)
                fprintf(f, "%d)\n", k);
            for(j = 0; j < c4;){
                if(debug)
                    printf("%2d", mas[j]);
                if(write_in_file)
                    fprintf(f, "%2d", mas[j]);
                j++;
                if(!(j % c2)){
                    if(debug)
                        printf("\n");
                    if(write_in_file)
                        fprintf(f, "\n");
                }
            }
            if(debug)
                printf("\n");
            if(write_in_file)
                fprintf(f, "\n");
            i--;
            mod = 1;
        }else if(mas[i] > 0){
            // если текущий элемент на i-ой позиции - неизменный
            if(mod)
                i--;
            else
                i++;
        }else{
            // найти новый подходящий элемент на i-ой позиции
            b = false;
            col = i % c2;
            row = int(i / c2);
            box = int(col / c) + int(row / c) * c;
            v = abs(mas[i]);
            if(mod){
                // если переход в i-ую позицию произошел из i+1-ой, сменить значение элемента на i-ой позиции
                v--;
                // сделать прошлое значение доступным для следующего выбора
                test[col * c2 + v] = test[c4 + row * c2 + v] = test[2 * c4 + box * c2 + v] = 1;
            }
            if(v)
                do{
                    v--;
                    // проверка удовлетворяет ли искомый элемент условия выбора
                    if(test[col * c2 + v])
                        if(test[c4 + row * c2 + v])
                            if(test[2 * c4 + box * c2 + v])
                                b = true;
                }while(!b && (v > 0));
            if(b){
                // удовлетворяет, перейти на i+1-ую позицию
                test[col * c2 + v] = test[c4 + row * c2 + v] = test[2 * c4 + box * c2 + v] = 0;
                mas[i] = -v - 1;
                mod = 0;
                i++;
            }else{
                // не удовлетворяет, откат на i-1-ую позицию
                mod = 1;
                mas[i] = -c2;
                i--;
            }
        }
    }
    if(write_in_file)
        fclose(f);
    delete []mas;
    // вернуть количество результатов
    return k;
}